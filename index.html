<!DOCTYPE html>
<html>
<head>
    <title>WebGL Sphere Demo</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        button {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: rgba(255, 255, 255, 1);
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div class="controls">
        <div class="control-group">
            <button id="zoomIn">Zoom In</button>
            <button id="zoomOut">Zoom Out</button>
        </div>
        <div class="control-group">
            <button id="rotateLeft">Rotate Left</button>
            <button id="rotateRight">Rotate Right</button>
        </div>
        <div class="control-group">
            <button id="rotateUp">Rotate Up</button>
            <button id="rotateDown">Rotate Down</button>
        </div>
    </div>

    <div id="fpsDisplay" style="position: fixed; top: 10px; left: 10px; color: white; background-color: rgba(0,0,0,0.5); padding: 5px;">FPS: 0</div>

    <!-- Vertex Shader -->
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform mat3 uNormalMatrix;
        
        varying vec3 vNormal;
        varying vec3 vPosition;

        // PS1-style vertex snapping parameters
        const float snapFactor = 50.0; // Increased from 20.0 to reduce jitter
        
        void main() {
            // For flat shading, just pass the normal directly without any interpolation
            vNormal = uNormalMatrix * aVertexNormal;
            vPosition = vec3(uModelViewMatrix * vec4(aVertexPosition, 1.0));
            
            vec4 projectedPosition = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);

            // Apply vertex snapping in screen space
            projectedPosition.xyz /= projectedPosition.w; // Perspective divide
            projectedPosition.xy = floor(projectedPosition.xy * snapFactor) / snapFactor; // Snap X and Y
            projectedPosition.xyz *= projectedPosition.w; // Multiply back by W

            gl_Position = projectedPosition;
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        uniform vec3 uLightDirection;
        uniform vec3 uLightColor;
        uniform vec3 uAmbientColor;

        // Bayer matrix (4x4) for ordered dithering
        // Using a simple 2x2 matrix for simplicity, scaled up
        const mat2 bayerMatrix = mat2(
            0.0, 2.0,
            3.0, 1.0
        ) / 4.0; // Divide by matrix size squared

        const float ditherScale = 20.0 / 16.0; // Controls the intensity of dithering

        void main() {
            // For flat shading, we can directly use the normal without normalization
            // since all vertices in a face have the exact same normal
            vec3 normal = vNormal;
            vec3 lightDir = normalize(uLightDirection);
            
            float diffuse = max(dot(normal, lightDir), 0.0);
            vec3 color = vec3(0.0, 1.0, 0.0); // Green color for sphere
            
            vec3 ambient = uAmbientColor * color;
            vec3 diffuseColor = uLightColor * color * diffuse;
            
            vec3 finalColor = ambient + diffuseColor;

            // Apply ordered dithering
            // Get screen coordinates (modulo 2 for 2x2 matrix)
            float x = mod(gl_FragCoord.x, 2.0);
            float y = mod(gl_FragCoord.y, 4.0);
            
            // Look up value in Bayer matrix
            // Need to cast float indices to int (not directly possible, use conditional logic)
            float ditherValue;
            if (x < 1.0) {
                if (y < 1.0) ditherValue = bayerMatrix[0][0];
                else ditherValue = bayerMatrix[0][1];
            } else {
                if (y < 1.0) ditherValue = bayerMatrix[1][0];
                else ditherValue = bayerMatrix[1][1];
            }

            // Add dither offset to color components
            // Subtract 0.5 to center the dither around zero
            vec3 ditherOffset = vec3(ditherScale * (ditherValue - 0.5));
            finalColor += ditherOffset;

            // Clamp color to [0, 1] range
            finalColor = clamp(finalColor, 0.0, 1.0);

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <!-- Wireframe Fragment Shader -->
    <script id="wireframeFragmentShader" type="x-shader/x-fragment">
        precision mediump float;
        
        void main() {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black color for wireframe
        }
    </script>

    <script>
        // WebGL context
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        const fpsDisplay = document.getElementById('fpsDisplay'); // Get the FPS display element
        
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Shader compilation
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create shader program
        const vertexShader = compileShader(document.getElementById('vertexShader').text, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(document.getElementById('fragmentShader').text, gl.FRAGMENT_SHADER);
        const wireframeFragmentShader = compileShader(document.getElementById('wireframeFragmentShader').text, gl.FRAGMENT_SHADER);
        
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        const wireframeProgram = gl.createProgram();
        gl.attachShader(wireframeProgram, vertexShader);
        gl.attachShader(wireframeProgram, wireframeFragmentShader);
        gl.linkProgram(wireframeProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Shader program linking error:', gl.getProgramInfoLog(shaderProgram));
        }

        if (!gl.getProgramParameter(wireframeProgram, gl.LINK_STATUS)) {
            console.error('Wireframe program linking error:', gl.getProgramInfoLog(wireframeProgram));
        }

        // Get attribute and uniform locations for both programs
        const attribLocations = {
            vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
            vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal')
        };

        const wireframeAttribLocations = {
            vertexPosition: gl.getAttribLocation(wireframeProgram, 'aVertexPosition'),
            vertexNormal: gl.getAttribLocation(wireframeProgram, 'aVertexNormal')
        };

        const uniformLocations = {
            projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
            modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
            normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
            lightDirection: gl.getUniformLocation(shaderProgram, 'uLightDirection'),
            lightColor: gl.getUniformLocation(shaderProgram, 'uLightColor'),
            ambientColor: gl.getUniformLocation(shaderProgram, 'uAmbientColor')
        };

        const wireframeUniformLocations = {
            projectionMatrix: gl.getUniformLocation(wireframeProgram, 'uProjectionMatrix'),
            modelViewMatrix: gl.getUniformLocation(wireframeProgram, 'uModelViewMatrix'),
            normalMatrix: gl.getUniformLocation(wireframeProgram, 'uNormalMatrix')
        };

        // Create sphere geometry
        function createSphere(radius, segments) {
            const positions = [];
            const normals = [];
            const indices = [];

            // Function to calculate face normal
            function calculateFaceNormal(v1, v2, v3) {
                // Create vectors from vertices
                const a = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
                const b = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
                
                // Cross product
                const normal = [
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ];
                
                // Normalize
                const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
                
                // For a sphere, we can ensure the normal points outward by checking dot product with position
                // This is specifically for a sphere centered at origin
                const center = [0, 0, 0];
                const toCenter = [
                    center[0] - v1[0],
                    center[1] - v1[1],
                    center[2] - v1[2]
                ];
                
                // Calculate dot product to check direction
                const dot = normal[0] * toCenter[0] + normal[1] * toCenter[1] + normal[2] * toCenter[2];
                
                // If normal points inward (toward center), flip it
                const sign = dot > 0 ? -1 : 1;
                
                return [
                    sign * normal[0] / length,
                    sign * normal[1] / length,
                    sign * normal[2] / length
                ];
            }

            // First, generate vertices position data (temporary)
            const tempPositions = [];
            for (let lat = 0; lat <= segments; lat++) {
                const theta = lat * Math.PI / segments;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);

                for (let lon = 0; lon <= segments; lon++) {
                    const phi = lon * 2 * Math.PI / segments;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);

                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;

                    tempPositions.push([radius * x, radius * y, radius * z]);
                }
            }

            // For flat shading, create duplicated vertices for each triangle face
            let index = 0;
            for (let lat = 0; lat < segments; lat++) {
                for (let lon = 0; lon < segments; lon++) {
                    const first = lat * (segments + 1) + lon;
                    const second = first + segments + 1;
                    
                    // Triangle 1 vertices
                    const v1 = tempPositions[first];
                    const v2 = tempPositions[second];
                    const v3 = tempPositions[first + 1];
                    
                    // Triangle 2 vertices
                    const v4 = tempPositions[second];
                    const v5 = tempPositions[second + 1];
                    const v6 = tempPositions[first + 1];
                    
                    // Calculate face normals
                    const normal1 = calculateFaceNormal(v1, v2, v3);
                    const normal2 = calculateFaceNormal(v4, v5, v6);
                    
                    // Triangle 1 - add to final arrays with duplicated vertices
                    positions.push(...v1, ...v2, ...v3);
                    normals.push(...normal1, ...normal1, ...normal1); // Same normal for all vertices in the face
                    indices.push(index, index + 1, index + 2);
                    index += 3;
                    
                    // Triangle 2 - add to final arrays with duplicated vertices
                    positions.push(...v4, ...v5, ...v6);
                    normals.push(...normal2, ...normal2, ...normal2); // Same normal for all vertices in the face
                    indices.push(index, index + 1, index + 2);
                    index += 3;
                }
            }

            return { positions, normals, indices };
        }

        // Create buffers
        const sphere = createSphere(1.0, 10); // Lowered segments from 12 to 6
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphere.positions), gl.STATIC_DRAW);

        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphere.normals), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphere.indices), gl.STATIC_DRAW);

        // Matrix operations
        const mat4 = {
            create: () => new Float32Array(16),
            identity: (out) => {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            },
            perspective: (out, fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) / (near - far);
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) / (near - far);
                out[15] = 0;
                return out;
            },
            translate: (out, a, v) => {
                const x = v[0], y = v[1], z = v[2];
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                return out;
            },
            rotateY: (out, a, rad) => {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                out[0] = a00 * c - a20 * s;
                out[1] = a01 * c - a21 * s;
                out[2] = a02 * c - a22 * s;
                out[3] = a03 * c - a23 * s;
                out[8] = a00 * s + a20 * c;
                out[9] = a01 * s + a21 * c;
                out[10] = a02 * s + a22 * c;
                out[11] = a03 * s + a23 * c;
                return out;
            },
            rotateX: (out, a, rad) => {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s;
                out[9] = a21 * c - a11 * s;
                out[10] = a22 * c - a12 * s;
                out[11] = a23 * c - a13 * s;
                return out;
            }
        };

        const mat3 = {
            create: () => new Float32Array(9),
            fromMat4: (out, a) => {
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2];
                out[3] = a[4]; out[4] = a[5]; out[5] = a[6];
                out[6] = a[8]; out[7] = a[9]; out[8] = a[10];
                return out;
            }
        };

        // Matrices
        const projectionMatrix = mat4.create();
        const modelViewMatrix = mat4.create();
        const normalMatrix = mat3.create();

        // Animation variables
        let cameraDistance = 3.0;
        const rotationSpeed = 0.2; // Doubled from 0.1
        const zoomSpeed = 0.4; // Doubled from 0.2

        // Mouse interaction state
        let isDragging = false;
        let lastMouseX = -1;
        let lastMouseY = -1;
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        const rotationSensitivity = 0.005; // Adjust sensitivity as needed

        // FPS calculation variables & Frame rate control
        let frameCount = 0;
        let fpsLastTime = performance.now() / 1000; // For FPS display updates

        const targetFPS = 20;
        const fpsInterval = 1000 / targetFPS;
        let then = performance.now();

        // Add button event listeners
        document.getElementById('zoomIn').addEventListener('click', () => {
            cameraDistance = Math.max(1.0, cameraDistance - zoomSpeed);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            cameraDistance = Math.min(10.0, cameraDistance + zoomSpeed);
        });

        document.getElementById('rotateLeft').addEventListener('click', () => {
            cameraAngleY += rotationSpeed;
        });

        document.getElementById('rotateRight').addEventListener('click', () => {
            cameraAngleY -= rotationSpeed;
        });

        document.getElementById('rotateUp').addEventListener('click', () => {
            cameraAngleX = Math.min(Math.PI/2 - 0.1, cameraAngleX + rotationSpeed);
        });

        document.getElementById('rotateDown').addEventListener('click', () => {
            cameraAngleX = Math.max(-Math.PI/2 + 0.1, cameraAngleX - rotationSpeed);
        });

        // Render function
        function render(now) {
            requestAnimationFrame(render); // Schedule the next frame immediately

            const elapsed = now - then;

            // if enough time has elapsed, draw the next frame
            if (elapsed > fpsInterval) {
                // Get ready for next frame by setting then=now, but also, adjust for your
                // specified fpsInterval not being a multiple of RAF's interval.
                then = now - (elapsed % fpsInterval);

                // --- Start of actual rendering logic ---
                gl.clearColor(0.0, 0.0, 1.0, 1.0); // Blue background
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Calculate FPS
                frameCount++;
                const currentTimeForFPS = now / 1000; // Convert to seconds (using 'now' from rAF)
                const deltaTimeForFPS = currentTimeForFPS - fpsLastTime;

                if (deltaTimeForFPS >= 1.0) { // Update FPS display every second
                    const fps = frameCount / deltaTimeForFPS;
                    fpsDisplay.textContent = `FPS: ${fps.toFixed(2)}`;
                    frameCount = 0;
                    fpsLastTime = currentTimeForFPS;
                }

                // Update camera position
                const cameraX = Math.sin(cameraAngleX) * cameraDistance;
                const cameraZ = Math.cos(cameraAngleX) * cameraDistance;

                // Set up matrices
                mat4.perspective(projectionMatrix, 45 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100.0);
                mat4.identity(modelViewMatrix);
                mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -cameraDistance]);
                // Apply rotations based on mouse movement
                mat4.rotateY(modelViewMatrix, modelViewMatrix, cameraAngleY); // Yaw
                mat4.rotateX(modelViewMatrix, modelViewMatrix, cameraAngleX); // Pitch
                mat3.fromMat4(normalMatrix, modelViewMatrix);

                // Draw solid sphere
                gl.useProgram(shaderProgram);

                // Set uniforms
                gl.uniformMatrix4fv(uniformLocations.projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(uniformLocations.modelViewMatrix, false, modelViewMatrix);
                gl.uniformMatrix3fv(uniformLocations.normalMatrix, false, normalMatrix);
                gl.uniform3fv(uniformLocations.lightDirection, [1.0, 2.0, 1.0]);
                gl.uniform3fv(uniformLocations.lightColor, [1.0, 1.0, 1.0]);
                gl.uniform3fv(uniformLocations.ambientColor, [0.1, 0.1, 0.1]);

                // Set up attributes
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(attribLocations.vertexPosition);

                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.vertexAttribPointer(attribLocations.vertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(attribLocations.vertexNormal);

                // Draw solid sphere
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0);

                // Draw wireframe
                gl.useProgram(wireframeProgram);

                // Set uniforms for wireframe
                gl.uniformMatrix4fv(wireframeUniformLocations.projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(wireframeUniformLocations.modelViewMatrix, false, modelViewMatrix);
                gl.uniformMatrix3fv(wireframeUniformLocations.normalMatrix, false, normalMatrix);

                // Set up attributes for wireframe
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(wireframeAttribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(wireframeAttribLocations.vertexPosition);

                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.vertexAttribPointer(wireframeAttribLocations.vertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(wireframeAttribLocations.vertexNormal);

                // Enable polygon offset to prevent z-fighting
                gl.enable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(1.0, 1.0);

                // Draw wireframe
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.drawElements(gl.LINE_LOOP, sphere.indices.length, gl.UNSIGNED_SHORT, 0);

                // Disable polygon offset
                gl.disable(gl.POLYGON_OFFSET_FILL);
                // --- End of actual rendering logic ---
            }
        }

        // Enable depth testing
        gl.enable(gl.DEPTH_TEST);

        // Start animation
        requestAnimationFrame(render);

        // Add mouse event listeners
        canvas.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // Left mouse button
                isDragging = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        });

        canvas.addEventListener('mouseup', (event) => {
            if (event.button === 0) { // Left mouse button
                isDragging = false;
            }
        });

        canvas.addEventListener('mousemove', (event) => {
            if (!isDragging) return;

            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;

            cameraAngleY += deltaX * rotationSensitivity;
            cameraAngleX += deltaY * rotationSensitivity;

            // Clamp pitch to avoid flipping
            cameraAngleX = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, cameraAngleX));

            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        });

        // Prevent context menu on right-click drag (optional)
        canvas.addEventListener('contextmenu', (event) => event.preventDefault());
    </script>
</body>
</html> 